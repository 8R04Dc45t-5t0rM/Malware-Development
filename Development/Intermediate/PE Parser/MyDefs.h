#include "WinDefs.h"
#include <stdio.h>

class PE64{
public:
PE64(char *Name, FILE *pFile);
void printInfo();

private:
char *Name;
FILE *pFile;

_IMAGE_DOS_HEADER DOS_HEADER;
_IMAGE_NT_HEADERS64 NT_HEADER;
PIMAGE_SECTION_HEADER SECTION_HEADERS;

void ParseFile();
void parseDOS();
void parseNT();
void parseSECTION_HEADERS();


void printDOS();
void printNT();
void printNT_optional();
void printNT_optional_DataDirectories();
int printNT_optional_DataDirectories_Export();
void printNT_optional_DataDirectories_Import(); /* NOT DONE YET*/
void printSECTION_HEADERS();

void printDescriptorName(DWORD);


int GetSectionIndex(DWORD);
int GetRVA(DWORD, int);
};


PE64 :: PE64(char *Name, FILE *pFile){
    PE64::Name = Name;
    PE64::pFile = pFile; 

    ParseFile();
    printInfo();
}


// pasring Functions 
void PE64 :: ParseFile(){
    parseDOS();
    parseNT();
    parseSECTION_HEADERS();
}

void PE64 :: parseDOS(){
    fseek(pFile,0,SEEK_SET);
    fread(&DOS_HEADER,sizeof(_IMAGE_DOS_HEADER),1,pFile);
}

void PE64 :: parseNT(){
    fseek(pFile,DOS_HEADER.e_lfanew,SEEK_SET);
    fread(&NT_HEADER,sizeof(IMAGE_NT_HEADERS64),1,pFile);
}

void PE64 :: parseSECTION_HEADERS(){
    SECTION_HEADERS = new IMAGE_SECTION_HEADER[NT_HEADER.FileHeader.NumberOfSections];
    for(int i=0 ; i<NT_HEADER.FileHeader.NumberOfSections;i++){
        fseek(pFile,(DOS_HEADER.e_lfanew+sizeof(NT_HEADER))+(i*IMAGE_SIZEOF_SECTION_HEADER),SEEK_SET);
        fread(&SECTION_HEADERS[i],IMAGE_SIZEOF_SECTION_HEADER,1,pFile);
    }

}


// printing funcitons 
void PE64 :: printDOS(){
    printf("\n\n ________ DOS HEADER DATA ___________\n\n");
    printf(" - Magic 0x%x\n",DOS_HEADER.e_magic);
    printf(" - Address of the exe 0x%x\n",DOS_HEADER.e_lfanew);
}

void PE64 :: printDescriptorName(DWORD NameVA){
    int ActualAddress = GetRVA(NameVA,GetSectionIndex(NameVA));
    int size = 0;

    DWORD Two_chars;
    while(true){
        fseek(pFile,ActualAddress+size,SEEK_SET);
        fread(&Two_chars,sizeof(DWORD),1,pFile);

        if(Two_chars == 0x0000){ break;}
        
        size+=2;
    }

    char Name[size+2];
    fseek(pFile,ActualAddress,SEEK_SET);
    fread(&Name,size+2,1,pFile);
    printf("     * %s\n",Name);
}

void PE64 ::  printNT_optional_DataDirectories_Import(){
    _IMAGE_DATA_DIRECTORY IM_DATA_DIRECTORY = NT_HEADER.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    printf("\n      - Import Directory (Data Within DataDirectory)\n");
    printf("         VA : 0x%x \n",IM_DATA_DIRECTORY.VirtualAddress);
    printf("         Size : 0x%x\n",IM_DATA_DIRECTORY.Size);

   
    int ActualAddress = GetRVA(IM_DATA_DIRECTORY.VirtualAddress,GetSectionIndex(IM_DATA_DIRECTORY.VirtualAddress));  
    int import_descriptors_count =0;
    int offset;

    while(true){
        IMAGE_IMPORT_DESCRIPTOR DES;
        offset = ActualAddress + import_descriptors_count * sizeof(IMAGE_IMPORT_DESCRIPTOR);  
        fseek(pFile,offset,SEEK_SET);
        fread(&DES,sizeof(IMAGE_IMPORT_DESCRIPTOR),1,pFile);

        if(DES.Name == 0x00000000 && DES.FirstThunk == 0x00000000){
            break;
        }
        else{
            import_descriptors_count++;
        }
    }
    printf("         Number of import descriptors : %d\n\n",import_descriptors_count);
    printf("\n  ____ Import Table ____ \n\n");
    PIMAGE_IMPORT_DESCRIPTOR IMPORT_TABLE = new IMAGE_IMPORT_DESCRIPTOR[import_descriptors_count];

    for (int i=0 ; i<import_descriptors_count ; i++){
        offset = ActualAddress + i*sizeof(IMAGE_IMPORT_DESCRIPTOR);
        fseek(pFile,offset,SEEK_SET);
        fread(&IMPORT_TABLE[i],sizeof(IMAGE_IMPORT_DESCRIPTOR),1,pFile);

        printDescriptorName(IMPORT_TABLE[i].Name);
        printf("         OG First Thunk : %x\n",IMPORT_TABLE[i].OriginalFirstThunk);
        printf("         First Thunk : %x\n\n",IMPORT_TABLE[i].FirstThunk);
       
    }

   
     
}

int PE64 :: printNT_optional_DataDirectories_Export(){
    _IMAGE_DATA_DIRECTORY EX_DATA_DIRECTORY = NT_HEADER.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    printf("     - Export Directory (Data Within DataDirectory)\n");
    printf("         VA : 0x%x \n",EX_DATA_DIRECTORY.VirtualAddress);
    printf("         Size : 0x%x\n\n",EX_DATA_DIRECTORY.Size);

    if(EX_DATA_DIRECTORY.VirtualAddress == 0x00){
        return 0;
    }
    int offset = GetRVA(EX_DATA_DIRECTORY.VirtualAddress,GetSectionIndex(EX_DATA_DIRECTORY.VirtualAddress));

    _IMAGE_EXPORT_DIRECTORY EX_DIRECTORY;
    fseek(pFile,offset,SEEK_SET);
    fread(&EX_DIRECTORY,EX_DATA_DIRECTORY.Size,1,pFile);

    printf("     - Export Directory (Itself)\n");
    printf("         Name : 0x%x\n",EX_DIRECTORY.Name);
    printf("         Base : 0x%x\n\n",EX_DIRECTORY.Base); 
    printf("         Numbers  \n");
    printf("           Of Functions : 0x%x\n",EX_DIRECTORY.NumberOfFunctions);
    printf("           Of Name : 0x%x\n\n",EX_DIRECTORY.NumberOfNames);
    printf("         RVAs \n");
    printf("           Functions : 0x%x\n",EX_DIRECTORY.AddressOfFunctions);
    printf("           Names : 0x%x\n",EX_DIRECTORY.AddressOfNames);
    printf("           Ordinals : 0x%x\n",EX_DIRECTORY.AddressOfNameOrdinals);

    return 1;

}

void PE64 :: printNT_optional_DataDirectories(){
    printf("\n\n ________  DATA DIRECTORIES _______\n\n");
    printNT_optional_DataDirectories_Export();
    printNT_optional_DataDirectories_Import();
}

void PE64 :: printNT_optional(){
    printf("     MagicPE: 0x%x\n",NT_HEADER.OptionalHeader.Magic);
    printf("     Sizes\n");
    printf("        image : 0x%x\n",NT_HEADER.OptionalHeader.SizeOfImage);
    printf("        .text : 0x%x\n",NT_HEADER.OptionalHeader.SizeOfCode);
    printf("        .data : 0x%x\n",NT_HEADER.OptionalHeader.SizeOfInitializedData);
    printf("        .bss : 0x%x\n\n",NT_HEADER.OptionalHeader.SizeOfUninitializedData);
    printf("     RVAs\n");
    printf("         .text : 0x%x\n\n",NT_HEADER.OptionalHeader.BaseOfCode);
    printf("     Alignments\n");
    printf("         Section : 0x%x\n",NT_HEADER.OptionalHeader.SectionAlignment);
    printf("         File : 0x%x\n",NT_HEADER.OptionalHeader.FileAlignment);
    printNT_optional_DataDirectories();
}

void PE64 :: printNT(){
    printf("\n\n ________  NT HEADER DATA ___________\n\n");
    printf(" - Signature 0x%x\n\n",NT_HEADER.Signature);
    printf(" - File Header Data  \n");
    printf("     Machine : 0x%x\n",NT_HEADER.FileHeader.Machine);
    printf("     Number of Sections : 0x%x\n",NT_HEADER.FileHeader.NumberOfSections);
    printf("     Size of Optional Headers : 0x%x\n\n",NT_HEADER.FileHeader.SizeOfOptionalHeader);
    printf(" - Optional Header Data  \n");
    printNT_optional();
}

void PE64 :: printSECTION_HEADERS(){
    printf("\n\n ________  SECTION HEADERS  _________\n\n");

    for (int i=0 ; i<NT_HEADER.FileHeader.NumberOfSections ;i++){
    printf("%s\n" ,SECTION_HEADERS[i].Name);
    printf("   - VA : 0x%x\n",SECTION_HEADERS[i].VirtualAddress);
    printf("   - Virtual Size : 0x%x\n",SECTION_HEADERS[i].Misc.VirtualSize);
    printf("   - PointerToRawData : 0x%x\n",SECTION_HEADERS[i].PointerToRawData);
    printf("   - Size OfRawData: 0x%x\n\n",SECTION_HEADERS[i].SizeOfRawData);
    }

}

void PE64 :: printInfo(){
printDOS();
printNT();
printSECTION_HEADERS();
}



int PE64 :: GetSectionIndex(DWORD VA){
    for(int i=0;i<NT_HEADER.FileHeader.NumberOfSections;i++){
        if(VA >= SECTION_HEADERS[i].VirtualAddress && VA < SECTION_HEADERS[i].VirtualAddress+SECTION_HEADERS[i].Misc.VirtualSize) {
            return i;
        }
    }
    return -1;
} 

int PE64 :: GetRVA(DWORD VA, int index){
    return VA - SECTION_HEADERS[index].VirtualAddress + SECTION_HEADERS[index].PointerToRawData;
}
